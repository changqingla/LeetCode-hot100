# 哈希表专题

## 🔍 哈希表基础知识

### 📖 定义

**哈希表**（Hash Table），也称为**散列表**，是一种基于键值对（key-value）存储数据的数据结构。它通过哈希函数将键映射到表中的位置，从而实现快速的数据存取操作。

### ⚡ 时间复杂度
- **平均情况**：O(1) - 插入、删除、查找
- **最坏情况**：O(n) - 当所有键都映射到同一位置时

### 🐍 Python中的哈希表实现

#### 1. 内置字典（dict）
```python
# 最常用的哈希表实现
hash_table = {}
hash_table['key1'] = 'value1'
hash_table['key2'] = 'value2'

# 或者直接初始化
hash_table = {
    'name': '张三',
    'age': 25,
    'city': '北京'
}

# 基本操作
print(hash_table['name'])  # 查找
hash_table['email'] = 'zhang@example.com'  # 插入
del hash_table['age']  # 删除
```

#### 2. 集合（set）
```python
# 初始化
my_set = set([1, 2, 3, 4, 5])

# 基本操作
my_set.add(6)  # 插入
my_set.remove(3)  # 删除
print(2 in my_set)  # 查找
```

#### 3. collections.defaultdict
```python
from collections import defaultdict

# 自动创建默认值
hash_table = defaultdict(list)
hash_table['fruits'].append('apple')
hash_table['fruits'].append('banana')
```

#### 4. collections.Counter
```python
from collections import Counter

# 专门用于计数的哈希表
text = "hello world"
char_count = Counter(text)
print(char_count)  # Counter({'l': 3, 'o': 2, ...})
```

---

## 📋 题目目录

| 题号 | 题目名称 | 难度 | 核心技巧 |
|------|----------|------|----------|
| 1 | 两数之和 | 简单 | 哈希表存储 |
| 31 | 下一个排列 | 中等 | 原地修改 |
| 49 | 字母异位词分组 | 中等 | 字符串排序作为key |
| 76 | 最小覆盖子串 | 困难 | 滑动窗口+哈希表 |
| 128 | 最长连续序列 | 中等 | 哈希表去重+查找 |
| 160 | 相交链表 | 简单 | 哈希表存储节点 |
| 169 | 多数元素 | 简单 | 计数哈希表 |
| 448 | 找到所有数组中消失的数字 | 简单 | 索引标记法 |

---

## 1. 两数之和

**题目描述：**

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

**约束条件：**
- 你可以假设每种输入只会对应一个答案
- 你不能使用两次相同的元素
- 你可以按任意顺序返回答案

**最简单实现：**

```python
def twoSum(nums, target):
    """
    使用哈希表一次遍历解决两数之和问题
    
    思路：
    1. 遍历数组，对于每个元素num，计算complement = target - num
    2. 检查complement是否已经在哈希表中
    3. 如果存在，返回两个索引；否则将当前元素存入哈希表
    
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    hash_map = {}  # 存储 {数值: 索引} 的映射
    
    for i, num in enumerate(nums):
        complement = target - num  # 计算需要找的另一个数
        
        # 如果complement已经在哈希表中，说明找到了答案
        if complement in hash_map:
            return [hash_map[complement], i]
        
        # 将当前数字和索引存入哈希表
        hash_map[num] = i
    
    return []  # 题目保证有解，这行不会执行

# 测试用例
print(twoSum([2, 7, 11, 15], 9))  # 输出: [0, 1]
print(twoSum([3, 2, 4], 6))       # 输出: [1, 2]
```

---

## 31. 下一个排列

**题目描述：**

整数数组的一个**排列**就是将其所有成员以序列或线性顺序排列。

例如，`arr = [1,2,3]`，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]`。

整数数组的**下一个排列**是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

**示例说明：**
- `arr = [1,2,3]` 的下一个排列是 `[1,3,2]`
- `arr = [2,3,1]` 的下一个排列是 `[3,1,2]`
- `arr = [3,2,1]` 的下一个排列是 `[1,2,3]`，因为 `[3,2,1]` 不存在一个字典序更大的排列

给你一个整数数组 `nums`，找出 `nums` 的下一个排列。

**约束条件：**
- 必须原地修改，只允许使用额外常数空间

**测试用例：**

```
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
```

**最简单实现：**

```python
def nextPermutation(nums):
    """
    找到下一个排列的算法
    
    思路：
    1. 从右往左找第一个递减的位置i（nums[i] < nums[i+1]）
    2. 如果找不到，说明是最大排列，直接反转整个数组
    3. 从右往左找第一个大于nums[i]的数nums[j]
    4. 交换nums[i]和nums[j]
    5. 反转i+1到末尾的部分
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    n = len(nums)
    
    # 步骤1：从右往左找第一个递减的位置
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    
    # 如果没找到递减位置，说明是最大排列，直接反转
    if i == -1:
        nums.reverse()
        return
    
    # 步骤2：从右往左找第一个大于nums[i]的数
    j = n - 1
    while nums[j] <= nums[i]:
        j -= 1
    
    # 步骤3：交换nums[i]和nums[j]
    nums[i], nums[j] = nums[j], nums[i]
    
    # 步骤4：反转i+1到末尾的部分
    nums[i + 1:] = reversed(nums[i + 1:])

# 测试用例
nums1 = [1, 2, 3]
nextPermutation(nums1)
print(nums1)  # 输出: [1, 3, 2]

nums2 = [3, 2, 1]
nextPermutation(nums2)
print(nums2)  # 输出: [1, 2, 3]
```


---

## 49. 字母异位词分组

**题目描述：**

给你一个字符串数组，请你将**字母异位词**组合在一起。可以按任意顺序返回结果列表。

**测试用例：**

```
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

解释：
- 在 strs 中没有字符串可以通过重新排列来形成 "bat"
- 字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此
- 字符串 "ate"、"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此
```

**最简单实现：**

```python
def groupAnagrams(strs):
    """
    使用排序后的字符串作为key来分组字母异位词
    
    思路：
    1. 字母异位词排序后的结果是相同的
    2. 使用排序后的字符串作为哈希表的key
    3. 将原字符串添加到对应key的列表中
    
    时间复杂度：O(n * k * log k)，n是字符串数量，k是字符串平均长度
    空间复杂度：O(n * k)
    """
    from collections import defaultdict
    
    # 使用defaultdict自动创建空列表
    groups = defaultdict(list)
    
    for s in strs:
        # 将字符串排序作为key
        #sorted(s) ：将字符串 s 中的所有字符按字母顺序排序
        #- 例如： sorted("eat") → ['a', 'e', 't']
        #- 例如： sorted("tea") → ['a', 'e', 't']

        #''.join(...) ：将排序后的字符列表重新连接成字符串
        #- 例如： ''.join(['a', 'e', 't']) → "aet"

        key = ''.join(sorted(s))
        # 将原字符串添加到对应分组
        groups[key].append(s)
    
    # 返回所有分组的列表
    return list(groups.values())

# 测试用例
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
result = groupAnagrams(strs)
print(result)  # 输出: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
```

---

## 76. 最小覆盖子串

**题目描述：**

给你一个字符串 `s` 和一个字符串 `t`。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。

**约束条件：**
- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案

**测试用例：**

```
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'
```

**最简单实现：**

```python
def minWindow(s, t):
    """
    使用滑动窗口+哈希表找最小覆盖子串
    
    思路：
    1. 用哈希表记录t中每个字符的需要数量
    2. 使用双指针维护滑动窗口
    3. 右指针扩展窗口，左指针收缩窗口
    4. 当窗口包含t的所有字符时，尝试收缩左边界
    
    时间复杂度：O(|s| + |t|)
    空间复杂度：O(|s| + |t|)
    """
    #专门用于计数的哈希表
    from collections import Counter
    
    if not s or not t:
        return ""
    
    # 统计t中每个字符的数量
    need = Counter(t)
    window = {}  # 当前窗口中字符的数量
    
    left = right = 0  # 双指针
    valid = 0  # 窗口中满足need条件的字符个数
    
    # 记录最小覆盖子串的起始位置和长度
    start = 0
    min_len = float('inf')
    
    while right < len(s):
        # 扩大窗口
        c = s[right]
        right += 1
        
        # 更新窗口内数据
        if c in need:  # 只有当字符在need中时才更新
            window[c] = window.get(c, 0) + 1  # 字符c的数量增加
            if window[c] == need[c]: # 字符c的数量满足need的数量
                valid += 1
        
        # 判断左侧窗口是否要收缩
        while valid == len(need):
            # 更新最小覆盖子串
            if right - left < min_len: # 找到更短的子串
                start = left
                min_len = right - left
            
            # 移出窗口的字符
            d = s[left]
            left += 1
            
            # 更新窗口内数据
            if d in need: # 只有当字符在need中时才更新
                if window[d] == need[d]: # 字符d的数量满足need的数量
                    valid -= 1 # 字符d的数量不再满足need的数量
                window[d] -= 1 # 字符d的数量减少
            else: # 字符d不在need中
                window[d] -= 1 # 字符d的数量减少
    
    # 返回最小覆盖子串
    return "" if min_len == float('inf') else s[start:start + min_len]

# 测试用例
print(minWindow("ADOBECODEBANC", "ABC"))  # 输出: "BANC"
print(minWindow("a", "a"))                # 输出: "a"
print(minWindow("a", "aa"))               # 输出: ""
```



---

## 128. 最长连续序列

**题目描述：**

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

**约束条件：**
- 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题

**测试用例：**

```
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]，它的长度为 4
```

**最简单实现：**

```python
def longestConsecutive(nums):
    """
    使用哈希表找最长连续序列
    
    思路：
    1. 将所有数字放入set中，实现O(1)查找
    2. 遍历每个数字，只从连续序列的起点开始计算
    3. 起点的特征：num-1不在set中
    4. 从起点开始，不断查找num+1, num+2...直到断开
    
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    if not nums:
        return 0
    
    # 将数组转换为set，去重并支持O(1)查找
    num_set = set(nums)
    max_length = 0
    
    for num in num_set:
        # 只从连续序列的起点开始计算
        # 如果num-1存在，说明num不是起点
        if num - 1 not in num_set:
            current_num = num
            current_length = 1
            
            # 不断查找下一个连续的数字
            while current_num + 1 in num_set:
                current_num += 1
                current_length += 1
            
            # 更新最大长度
            max_length = max(max_length, current_length)
    
    return max_length

# 测试用例
print(longestConsecutive([100, 4, 200, 1, 3, 2]))  # 输出: 4
print(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]))  # 输出: 9
print(longestConsecutive([]))  # 输出: 0
```

---

## 160. 相交链表

**题目描述：**

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。

**说明：**
- 图示两个链表在节点 c1 开始相交

**最简单实现：**

```python
# 链表节点定义
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA, headB):
    """
    使用哈希表找两个链表的相交节点
    
    思路：
    1. 遍历链表A，将所有节点存入哈希表
    2. 遍历链表B，检查每个节点是否在哈希表中
    3. 第一个在哈希表中的节点就是相交节点
    
    时间复杂度：O(m + n)
    空间复杂度：O(m) 或 O(n)
    """
    if not headA or not headB:
        return None
    
    # 用set存储链表A的所有节点
    visited = set()
    
    # 遍历链表A，将所有节点加入set
    current = headA
    while current:
        visited.add(current)
        current = current.next
    
    # 遍历链表B，检查是否有节点在set中
    current = headB
    while current:
        if current in visited:
            return current  # 找到相交节点
        current = current.next
    
    return None  # 没有相交节点

# 更优雅的双指针解法（不使用额外空间）
def getIntersectionNodeOptimal(headA, headB):
    """
    双指针法：让两个指针分别遍历两个链表
    当指针到达末尾时，跳转到另一个链表的头部
    如果有相交，两个指针会在相交点相遇
    
    时间复杂度：O(m + n)
    空间复杂度：O(1)
    """
    if not headA or not headB:
        return None
    
    pA, pB = headA, headB
    
    # 两个指针同时移动，当到达末尾时跳转到另一个链表
    while pA != pB:
        pA = pA.next if pA else headB
        pB = pB.next if pB else headA
    
    return pA  # 相交节点或None
```

---

## 169. 多数元素

**题目描述：**

给定一个大小为 `n` 的数组 `nums`，返回其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

**约束条件：**
- 你可以假设数组是非空的，并且给定的数组总是存在多数元素

**测试用例：**

```
示例 1：
输入：nums = [3,2,3]
输出：3

示例 2：
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

**最简单实现：**

```python
def majorityElement(nums):
    """
    使用哈希表统计每个元素的出现次数
    
    思路：
    1. 遍历数组，统计每个元素的出现次数
    2. 找到出现次数大于 n/2 的元素
    
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    from collections import Counter
    
    # 统计每个元素的出现次数
    count = Counter(nums)
    n = len(nums)
    
    # 找到出现次数大于 n/2 的元素
    for num, freq in count.items():
        if freq > n // 2:
            return num

# 更简洁的写法
def majorityElementSimple(nums):
    """
    直接使用Counter的most_common方法
    """
    from collections import Counter
    return Counter(nums).most_common(1)[0][0]

# 最优解法：Boyer-Moore投票算法（O(1)空间）
def majorityElementOptimal(nums):
    """
    Boyer-Moore投票算法
    
    思路：
    1. 维护一个候选者和计数器
    2. 遇到相同元素计数+1，不同元素计数-1
    3. 计数为0时更换候选者
    4. 最后的候选者就是多数元素
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    candidate = None
    count = 0
    
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    
    return candidate

# 测试用例
print(majorityElement([3, 2, 3]))  # 输出: 3
print(majorityElement([2, 2, 1, 1, 1, 2, 2]))  # 输出: 2
```
---

## 448. 找到所有数组中消失的数字

**题目描述：**

给你一个含 `n` 个整数的数组 `nums`，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**测试用例：**

```
示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]

示例 2：
输入：nums = [1,1]
输出：[2]
```

**最简单实现：**

```python
def findDisappearedNumbers(nums):
    """
    使用set找到数组中消失的数字
    
    思路：
    1. 将数组转换为set，去除重复元素
    2. 创建完整的1到n的集合
    3. 两个集合相减得到消失的数字
    
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    n = len(nums)
    
    # 将数组转换为set
    num_set = set(nums)
    
    # 找到消失的数字
    result = []
    for i in range(1, n + 1):
        if i not in num_set:
            result.append(i)
    
    return result

# 更简洁的写法
def findDisappearedNumbersSimple(nums):
    """
    使用集合运算直接求差集
    """
    n = len(nums)
    return list(set(range(1, n + 1)) - set(nums))

# 最优解法：原地修改（不使用额外空间）
def findDisappearedNumbersOptimal(nums):
    """
    原地修改数组，利用索引标记已出现的数字
    
    思路：
    1. 遍历数组，对于每个数字num，将nums[num-1]标记为负数
    2. 再次遍历，索引对应的值为正数的位置就是消失的数字
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    # 第一次遍历：标记已出现的数字
    for num in nums:
        index = abs(num) - 1  # 数字对应的索引
        if nums[index] > 0:
            nums[index] = -nums[index]  # 标记为负数
    
    # 第二次遍历：找到未标记的位置
    result = []
    for i in range(len(nums)):
        if nums[i] > 0:
            result.append(i + 1)  # 索引+1就是消失的数字
    
    return result

# 测试用例
print(findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]))  # 输出: [5, 6]
print(findDisappearedNumbers([1, 1]))  # 输出: [2]
```

---

## 📝 解题思路与模板

### 🎯 哈希表解题的通用思路

1. **确定哈希表的用途**
   - 存储已访问的元素
   - 建立元素与索引的映射
   - 统计元素出现次数
   - 快速查找目标元素

2. **选择合适的数据结构**
   - `dict`：键值对映射
   - `set`：去重和快速查找
   - `defaultdict`：自动初始化默认值
   - `Counter`：计数统计

3. **常见解题模式**
   - **一次遍历**：边遍历边查找
   - **两次遍历**：先统计再处理
   - **滑动窗口**：动态维护窗口内元素

### 🔧 常用代码模板

#### 模板1：两数之和类型
```python
def two_sum_pattern(nums, target):
    hash_map = {}  # 存储 {值: 索引}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

#### 模板2：字符串分组类型
```python
def group_pattern(strs):
    from collections import defaultdict
    groups = defaultdict(list)
    for s in strs:
        key = ''.join(sorted(s))  # 生成分组key
        groups[key].append(s)
    return list(groups.values())
```

#### 模板3：滑动窗口+哈希表
```python
def sliding_window_pattern(s, t):
    from collections import Counter
    need = Counter(t)
    window = {}
    left = right = 0
    valid = 0
    
    while right < len(s):
        # 扩大窗口
        c = s[right]
        right += 1
        # 更新窗口数据
        if c in need:
            window[c] = window.get(c, 0) + 1
            if window[c] == need[c]:
                valid += 1
        
        # 收缩窗口
        while valid == len(need):
            # 更新结果
            d = s[left]
            left += 1
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1
```

#### 模板4：计数统计类型
```python
def count_pattern(nums):
    from collections import Counter
    count = Counter(nums)
    result = []
    for num, freq in count.items():
        if freq > len(nums) // 2:  # 满足某种条件
            result.append(num)
    return result
```

### 💡 解题技巧

1. **空间换时间**：用哈希表存储中间结果，避免重复计算
2. **一次遍历优化**：边遍历边处理，减少时间复杂度
3. **巧妙的key设计**：如字母异位词用排序后的字符串作key
4. **负索引技巧**：利用数组索引本身作为哈希表
5. **双哈希表**：分别统计两个集合，然后比较

### 🚨 常见陷阱

1. **重复元素处理**：注意题目是否允许使用同一元素多次
2. **边界条件**：空数组、单元素数组的处理
3. **哈希冲突**：虽然Python的dict处理了，但要理解原理
4. **内存溢出**：大数据量时考虑空间复杂度
5. **键的类型**：确保用作key的对象是可哈希的

## 🎯 刷题建议

### 📚 学习顺序
1. **基础题目**：1(两数之和) → 169(多数元素) → 448(消失的数字)
2. **进阶题目**：49(字母异位词分组) → 128(最长连续序列)
3. **困难题目**：76(最小覆盖子串)

### 🔄 练习方法
- **第一遍**：理解题意，尝试暴力解法
- **第二遍**：思考哈希表优化，实现O(n)解法
- **第三遍**：总结模板，举一反三
- **第四遍**：限时练习，提高编码速度

### 📊 掌握标准
- 能够快速识别哈希表适用场景
- 熟练使用Python的dict、set、Counter等
- 掌握常见的解题模板和技巧
- 能够分析时间空间复杂度
- 注意边界条件和特殊情况的处理