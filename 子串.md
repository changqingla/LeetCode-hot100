# 子串专题

## 🔍 子串基础知识

### 📖 定义

**子串**是字符串中连续的字符序列；**子数组**是数组中连续的元素序列。许多经典问题可在 O(n) 或 O(n log n) 时间内通过哈希、前缀和、单调队列或滑动窗口解决。

### 🎯 常见技巧
- **滑动窗口**：维护区间满足某种性质（如无重复、覆盖要求、固定长度等）
- **前缀和 + 哈希**：统计满足和为目标值的子数组个数
- **单调队列**：在滑动窗口中维护最大/最小值，O(1) 获得答案
- **双指针**：窗口伸缩的实现方式之一

---

## 📋 题目目录

| 题号 | 题目名称 | 难度 | 核心技巧 |
|------|----------|------|----------|
| 560 | 和为 K 的子数组 | 中等 | 前缀和 + 哈希 |
| 239 | 滑动窗口最大值 | 困难 | 单调队列 |
| 76 | 最小覆盖子串 | 困难 | 滑动窗口 + 计数 |

---

## 560. 和为 K 的子数组

**题目描述：**

给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的子数组的个数。子数组是数组中元素的连续非空序列。

**测试用例：**

```
示例 1：
输入：nums = [1,1,1], k = 2
输出：2

示例 2：
输入：nums = [1,2,3], k = 3
输出：2
```

**最简单实现：**

```python
from collections import defaultdict

def subarraySum(nums, k):
    """
    前缀和 + 哈希 统计和为k的子数组个数

    思路：
    1. 定义前缀和 prefixSum[i] = nums[0..i] 之和
    2. 对于每个位置的前缀和 curr，总有：如果存在 prev，使得 curr - prev = k，
       则 [prev_index+1 .. i] 这段子数组之和为 k
    3. 用哈希表 count 记录每个前缀和出现的次数，初始化 count[0] = 1（空前缀）

    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    count = defaultdict(int)
    count[0] = 1
    curr = 0
    ans = 0

    for x in nums:
        curr += x
        ans += count[curr - k]
        count[curr] += 1
    return ans

# 测试
print(subarraySum([1,1,1], 2))  # 2
print(subarraySum([1,2,3], 3))  # 2
```

**解题思路详解：**
- 将问题从“求区间和等于 k”转换为“找前缀和差值为 k”
- `count[curr - k]` 表示以当前结尾、和为 k 的子数组个数
- 初始化 `count[0]=1` 代表从起点到当前位置正好等于 k 的情况

---

## 239. 滑动窗口最大值

**题目描述：**

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。每次滑动窗口向右移动一位。返回滑动窗口中的最大值。

![滑动窗口最大值](./imgs/239.png)

**测试用例：**

```
示例：
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

**最简单实现（单调队列）：**

```python
from collections import deque

def maxSlidingWindow(nums, k):
    """
    单调队列：维护一个递减队列，队首始终为当前窗口最大值

    规则：
    - 入队：将队尾所有小于新元素的值弹出，再入队
    - 出队：当队首下标滑出窗口时弹出

    时间复杂度：O(n)
    空间复杂度：O(k)
    """
    if not nums or k == 0:
        return []

    q = deque()  # 存放下标，队列对应的值递减
    res = []

    for i, val in enumerate(nums):
        # 移除队尾所有小于当前值的元素（保持递减）
        while q and nums[q[-1]] <= val:
            q.pop()
        q.append(i)

        # 移除滑出窗口的队首
        if q[0] <= i - k:
            q.popleft()

        # 形成窗口后，记录最大值
        if i >= k - 1:
            res.append(nums[q[0]])
    return res

# 测试
print(maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))  # [3,3,5,5,6,7]
```

**思路要点：**
- 队列中下标对应的数值保持递减，队首永远是窗口最大值
- 每个元素最多进出队一次，保证 O(n)

---

## 76. 最小覆盖子串

**题目描述：**

给你一个字符串 `s`、一个字符串 `t`。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""`。

注意：
- 对于 `t` 中重复字符，子串中该字符数量必须不少于 `t` 中该字符数量
- 如果答案存在，保证唯一

**测试用例：**

```
示例 1：
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

示例 2：
输入：s = "a", t = "a"
输出："a"

示例 3：
输入：s = "a", t = "aa"
输出：""  # 不存在覆盖子串
```

**最简单实现（滑动窗口）：**

```python
from collections import Counter

def minWindow(s, t):
    """
    滑动窗口 + 计数：最小覆盖子串

    思路：
    1. 统计 t 的字符频率 need
    2. 右指针扩张窗口，更新满足度 matched
    3. 当窗口已覆盖 t（matched == len(need)）时，左指针收缩，尝试更新答案
    4. 收缩到刚好不满足为止，继续右移

    时间复杂度：O(n)
    空间复杂度：O(m)（m为字符集大小）
    """
    if not s or not t:
        return ""

    need = Counter(t)
    window = Counter()
    required = len(need)
    formed = 0

    left = 0
    best_len = float("inf")
    best_start = 0

    for right, ch in enumerate(s):
        window[ch] += 1
        if ch in need and window[ch] == need[ch]:
            formed += 1

        # 当已完全覆盖 t，尝试收缩左边界
        while formed == required:
            if right - left + 1 < best_len:
                best_len = right - left + 1
                best_start = left

            left_ch = s[left]
            window[left_ch] -= 1
            if left_ch in need and window[left_ch] < need[left_ch]:
                formed -= 1
            left += 1

    return "" if best_len == float("inf") else s[best_start:best_start + best_len]

# 测试
print(minWindow("ADOBECODEBANC", "ABC"))  # "BANC"
print(minWindow("a", "a"))                # "a"
print(minWindow("a", "aa"))               # ""
```

**解题思路详解：**
- 窗口维护的是“至少包含 t 中所有字符及其所需个数”的性质
- `formed == required` 表示当前窗口已经覆盖 t，可尝试收缩
- 每次收缩时更新最优解，保证最短
