# 普通数组专题

## 🔍 普通数组基础知识

### 📖 定义

**数组**（Array）是一种线性数据结构，用于存储相同类型的数据元素。数组中的元素通过索引访问，索引通常从0开始。普通数组问题主要涉及数组的遍历、查找、排序、合并等基本操作。

### ⚡ 核心特征

1. **连续存储**：数组元素在内存中连续存储
2. **随机访问**：可以通过索引O(1)时间访问任意元素
3. **固定大小**：大多数语言中数组大小固定（Python的list是动态的）

### 🎯 常见解题技巧

1. **前缀和/后缀和**：快速计算子数组和
2. **双指针**：对撞指针、快慢指针
3. **原地操作**：利用数组本身存储信息
4. **排序**：先排序后处理
5. **哈希表**：快速查找和计数

### 🐍 Python数组操作

```python
# 数组初始化
arr = [1, 2, 3, 4, 5]

# 基本操作
arr.append(6)        # 添加元素
arr.insert(0, 0)      # 插入元素
arr.pop()             # 删除末尾元素
arr.reverse()         # 反转数组
arr.sort()            # 排序

# 切片操作
arr[1:3]              # [2, 3]
arr[::-1]             # 反转
```

---

## 📋 题目目录

| 题号 | 题目名称 | 难度 | 核心技巧 |
|------|----------|------|----------|
| 53 | 最大子数组和 | 中等 | 动态规划/Kadane算法 |
| 56 | 合并区间 | 中等 | 排序+贪心 |
| 189 | 轮转数组 | 中等 | 数组翻转 |
| 238 | 除自身以外数组的乘积 | 中等 | 前缀积+后缀积 |
| 41 | 缺失的第一个正数 | 困难 | 原地哈希 |

---

## 53. 最大子数组和

**题目描述：**

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

**测试用例：**

```
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23
```

**最简单实现：**

```python
def maxSubArray(nums):
    """
    使用Kadane算法（动态规划）求解最大子数组和
    
    思路：
    1. 遍历数组，对于每个位置，计算以该位置结尾的最大子数组和
    2. 如果前面的和小于0，则重新开始（因为负数只会让和变小）
    3. 否则继续累加
    4. 实时更新全局最大值
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    if not nums:
        return 0
    
    max_sum = nums[0]  # 全局最大和
    current_sum = nums[0]  # 以当前位置结尾的最大和
    
    for i in range(1, len(nums)):
        # 如果前面的和小于0，重新开始
        # 否则继续累加
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
    
    return max_sum

# 测试用例
print(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))  # 输出: 6
print(maxSubArray([1]))                       # 输出: 1
print(maxSubArray([5,4,-1,7,8]))             # 输出: 23
```

**解题思路详解：**

这道题的核心是使用**Kadane算法**（动态规划思想）：

**核心原理：**
- 对于每个位置i，计算以i结尾的最大子数组和
- 如果前面的和是负数，不如重新开始
- 如果前面的和是正数，继续累加

**状态转移方程：**
- `dp[i] = max(nums[i], dp[i-1] + nums[i])`
- 可以优化为：`current_sum = max(nums[i], current_sum + nums[i])`

**算法流程：**
1. 初始化max_sum = nums[0], current_sum = nums[0]
2. 从i=1开始遍历：
   - current_sum = max(nums[i], current_sum + nums[i])
   - max_sum = max(max_sum, current_sum)
3. 返回max_sum

**举例说明：**
```
nums = [-2,1,-3,4,-1,2,1,-5,4]

i=0: current_sum=-2, max_sum=-2
i=1: current_sum=max(1, -2+1)=1, max_sum=1
i=2: current_sum=max(-3, 1-3)=-2, max_sum=1
i=3: current_sum=max(4, -2+4)=4, max_sum=4
i=4: current_sum=max(-1, 4-1)=3, max_sum=4
i=5: current_sum=max(2, 3+2)=5, max_sum=5
i=6: current_sum=max(1, 5+1)=6, max_sum=6 ← 最大值
i=7: current_sum=max(-5, 6-5)=1, max_sum=6
i=8: current_sum=max(4, 1+4)=5, max_sum=6

最终结果：6
```

**时间复杂度证明：**
- 只需遍历一次数组：O(n)
- 每个位置的操作：O(1)
- 总复杂度：O(n)

---

## 56. 合并区间

**题目描述：**

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**测试用例：**

```
示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。

示例 2：
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

示例 3：
输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。
```

**最简单实现：**

```python
def merge(intervals):
    """
    合并重叠区间
    
    思路：
    1. 先按区间起点排序
    2. 遍历区间，如果当前区间与结果中最后一个区间重叠，则合并
    3. 否则直接添加
    
    时间复杂度：O(n log n)，主要是排序
    空间复杂度：O(n)
    """
    if not intervals:
        return []
    
    # 按起点排序
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        # 获取结果中最后一个区间
        last = merged[-1]
        
        # 如果当前区间与最后一个区间重叠
        if current[0] <= last[1]:
            # 合并：更新最后一个区间的终点
            last[1] = max(last[1], current[1])
        else:
            # 不重叠，直接添加
            merged.append(current)
    
    return merged

# 测试用例
print(merge([[1,3],[2,6],[8,10],[15,18]]))  # 输出: [[1,6],[8,10],[15,18]]
print(merge([[1,4],[4,5]]))                  # 输出: [[1,5]]
print(merge([[4,7],[1,4]]))                  # 输出: [[1,7]]
```

**解题思路详解：**

这道题的核心是**排序 + 贪心**：

**为什么需要排序？**
- 排序后，重叠的区间会相邻
- 便于判断和合并

**合并条件：**
- 两个区间[a, b]和[c, d]重叠当且仅当：c <= b
- 合并后的区间：[min(a, c), max(b, d)]

**算法流程：**
1. 按区间起点排序
2. 初始化结果列表，放入第一个区间
3. 遍历后续区间：
   - 如果与结果中最后一个区间重叠，合并
   - 否则直接添加

**举例说明：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]

排序后：[[1,3],[2,6],[8,10],[15,18]]

处理[1,3]：merged=[[1,3]]
处理[2,6]：2 <= 3，重叠，合并为[1,6]，merged=[[1,6]]
处理[8,10]：8 > 6，不重叠，添加，merged=[[1,6],[8,10]]
处理[15,18]：15 > 10，不重叠，添加，merged=[[1,6],[8,10],[15,18]]

最终结果：[[1,6],[8,10],[15,18]]
```

**时间复杂度分析：**
- 排序：O(n log n)
- 遍历合并：O(n)
- 总复杂度：O(n log n)

---

## 189. 轮转数组

**题目描述：**

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**测试用例：**

```
示例 1：
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

示例 2：
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**最简单实现：**

```python
def rotate(nums, k):
    """
    轮转数组：使用三次翻转
    
    思路：
    1. 先处理k，k可能大于数组长度
    2. 翻转整个数组
    3. 翻转前k个元素
    4. 翻转后n-k个元素
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    n = len(nums)
    k = k % n  # 处理k大于数组长度的情况
    
    if k == 0:
        return
    
    # 翻转整个数组
    nums.reverse()
    
    # 翻转前k个元素
    nums[:k] = reversed(nums[:k])
    
    # 翻转后n-k个元素
    nums[k:] = reversed(nums[k:])

# 辅助函数：翻转数组的指定范围
def reverse(nums, left, right):
    """翻转数组从left到right的部分"""
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1

def rotate_optimized(nums, k):
    """
    优化版本：使用辅助函数
    """
    n = len(nums)
    k = k % n
    
    if k == 0:
        return
    
    # 翻转整个数组
    reverse(nums, 0, n - 1)
    # 翻转前k个
    reverse(nums, 0, k - 1)
    # 翻转后n-k个
    reverse(nums, k, n - 1)

# 测试用例
nums1 = [1,2,3,4,5,6,7]
rotate(nums1, 3)
print(nums1)  # 输出: [5,6,7,1,2,3,4]

nums2 = [-1,-100,3,99]
rotate(nums2, 2)
print(nums2)  # 输出: [3,99,-1,-100]
```

**解题思路详解：**

这道题的核心是使用**三次翻转**技巧：

**核心原理：**
- 向右轮转k位，相当于把后k个元素移到前面
- 可以通过三次翻转实现：
  1. 翻转整个数组
  2. 翻转前k个元素
  3. 翻转后n-k个元素

**为什么这样有效？**
```
原始数组：[1,2,3,4,5,6,7]，k=3

步骤1：翻转整个数组 → [7,6,5,4,3,2,1]
步骤2：翻转前3个    → [5,6,7,4,3,2,1]
步骤3：翻转后4个    → [5,6,7,1,2,3,4] ✓
```

**算法流程：**
1. k = k % n（处理k大于数组长度的情况）
2. 翻转整个数组
3. 翻转前k个元素
4. 翻转后n-k个元素

**举例说明：**
```
nums = [1,2,3,4,5,6,7], k = 3

翻转整个：[7,6,5,4,3,2,1]
翻转前3： [5,6,7,4,3,2,1]
翻转后4： [5,6,7,1,2,3,4] ✓
```

**时间复杂度证明：**
- 三次翻转，每次O(n)
- 总复杂度：O(n)

---

## 238. 除自身以外数组的乘积

**题目描述：**

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据 保证 数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。

请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

**测试用例：**

```
示例 1：
输入: nums = [1,2,3,4]
输出: [24,12,8,6]

示例 2：
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**最简单实现：**

```python
def productExceptSelf(nums):
    """
    除自身以外数组的乘积：使用前缀积和后缀积
    
    思路：
    1. 先计算前缀积：prefix[i] = nums[0] * nums[1] * ... * nums[i-1]
    2. 再计算后缀积：suffix[i] = nums[i+1] * nums[i+2] * ... * nums[n-1]
    3. answer[i] = prefix[i] * suffix[i]
    4. 优化：使用结果数组存储前缀积，然后从后往前计算后缀积
    
    时间复杂度：O(n)
    空间复杂度：O(1)（不考虑输出数组）
    """
    n = len(nums)
    answer = [1] * n
    
    # 计算前缀积
    for i in range(1, n):
        answer[i] = answer[i-1] * nums[i-1]
    
    # 计算后缀积并同时更新答案
    suffix = 1
    for i in range(n-1, -1, -1):
        answer[i] = answer[i] * suffix
        suffix = suffix * nums[i]
    
    return answer

# 测试用例
print(productExceptSelf([1,2,3,4]))        # 输出: [24,12,8,6]
print(productExceptSelf([-1,1,0,-3,3]))    # 输出: [0,0,9,0,0]
```

**解题思路详解：**

这道题的核心是使用**前缀积 + 后缀积**：

**核心原理：**
- answer[i] = 所有左边元素的乘积 × 所有右边元素的乘积
- 前缀积：prefix[i] = nums[0] × nums[1] × ... × nums[i-1]
- 后缀积：suffix[i] = nums[i+1] × nums[i+2] × ... × nums[n-1]

**为什么不能使用除法？**
- 如果数组中有0，除法会出错
- 题目要求不使用除法

**算法流程（优化版）：**
1. 初始化answer数组，全部为1
2. 计算前缀积：answer[i] = answer[i-1] × nums[i-1]
3. 从后往前计算后缀积，同时更新答案：
   - suffix = 1（初始）
   - answer[i] = answer[i] × suffix
   - suffix = suffix × nums[i]

**举例说明：**
```
nums = [1,2,3,4]

步骤1：计算前缀积
answer[0] = 1
answer[1] = 1 × 1 = 1
answer[2] = 1 × 2 = 2
answer[3] = 2 × 3 = 6
answer = [1,1,2,6]

步骤2：计算后缀积并更新
i=3: suffix=1, answer[3]=6×1=6, suffix=1×4=4
i=2: suffix=4, answer[2]=2×4=8, suffix=4×3=12
i=1: suffix=12, answer[1]=1×12=12, suffix=12×2=24
i=0: suffix=24, answer[0]=1×24=24, suffix=24×1=24

最终结果：[24,12,8,6]
```

**时间复杂度证明：**
- 两次遍历数组：O(n)
- 每个位置的操作：O(1)
- 总复杂度：O(n)

---

## 41. 缺失的第一个正数

**题目描述：**

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

**测试用例：**

```
示例 1：
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。

示例 2：
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。

示例 3：
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

**最简单实现：**

```python
def firstMissingPositive(nums):
    """
    缺失的第一个正数：使用原地哈希
    
    思路：
    1. 关键观察：答案一定在[1, n+1]范围内（n是数组长度）
    2. 如果数组包含1到n的所有数，答案是n+1
    3. 否则答案是第一个缺失的正数
    4. 使用数组本身作为哈希表：将数字i放到位置i-1
    
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    n = len(nums)
    
    # 第一步：将所有非正数和大于n的数标记为无效
    # 将它们替换为n+1（一个不会影响结果的数）
    for i in range(n):
        if nums[i] <= 0 or nums[i] > n:
            nums[i] = n + 1
    
    # 第二步：使用负号标记数字是否存在
    # 如果nums[i]在[1, n]范围内，将nums[nums[i]-1]标记为负数
    for i in range(n):
        num = abs(nums[i])
        if num <= n:
            # 将对应位置标记为负数（表示这个数字存在）
            nums[num - 1] = -abs(nums[num - 1])
    
    # 第三步：找到第一个正数位置，说明该位置对应的数字缺失
    for i in range(n):
        if nums[i] > 0:
            return i + 1
    
    # 如果所有位置都是负数，说明1到n都存在，答案是n+1
    return n + 1

# 测试用例
print(firstMissingPositive([1,2,0]))           # 输出: 3
print(firstMissingPositive([3,4,-1,1]))        # 输出: 2
print(firstMissingPositive([7,8,9,11,12]))    # 输出: 1
```

**解题思路详解：**

这道题的核心是使用**原地哈希**技巧：

**关键观察：**
- 答案一定在[1, n+1]范围内（n是数组长度）
- 如果数组包含1到n的所有数，答案是n+1
- 否则答案是第一个缺失的正数

**为什么使用原地哈希？**
- 需要O(n)时间复杂度和O(1)空间复杂度
- 不能使用额外的哈希表
- 利用数组本身作为哈希表

**算法流程：**
1. **清理数组**：将所有非正数和大于n的数替换为n+1
2. **标记存在**：遍历数组，如果nums[i]在[1, n]范围内，将nums[nums[i]-1]标记为负数
3. **查找缺失**：找到第一个正数位置i，返回i+1；如果都是负数，返回n+1

**标记技巧：**
- 使用负号标记数字是否存在
- 如果nums[i] = k（1 <= k <= n），将nums[k-1]标记为负数
- 这样nums[k-1] < 0表示数字k存在

**举例说明：**
```
nums = [3,4,-1,1]

步骤1：清理数组
[3,4,5,1]  (将-1替换为5，因为n=4)

步骤2：标记存在
i=0: num=3, nums[2]=5 → -5, [3,4,-5,1]
i=1: num=4, nums[3]=1 → -1, [3,4,-5,-1]
i=2: num=5, 超出范围，跳过
i=3: num=1, nums[0]=3 → -3, [-3,4,-5,-1]

步骤3：查找缺失
nums[1]=4 > 0，说明数字2缺失
返回2
```

**时间复杂度证明：**
- 三次遍历数组：O(n)
- 每个位置的操作：O(1)
- 总复杂度：O(n)

---

## 🎯 普通数组解题技巧总结

### 1. 前缀和/后缀和
```python
# 前缀和：快速计算子数组和
prefix = [0]
for num in nums:
    prefix.append(prefix[-1] + num)
# 子数组[i, j]的和 = prefix[j+1] - prefix[i]
```

### 2. 原地操作
```python
# 利用数组本身存储信息
# 例如：使用负号标记、使用索引映射等
```

### 3. 数组翻转
```python
# 三次翻转技巧
def reverse(nums, left, right):
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
```

### 4. 排序+贪心
```python
# 先排序，然后使用贪心策略
intervals.sort(key=lambda x: x[0])
```

普通数组问题通常需要灵活运用这些技巧，结合具体问题特点选择最合适的解法。
