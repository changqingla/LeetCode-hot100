# å›¾è®ºä¸“é¢˜

## ğŸ” å›¾è®ºåŸºç¡€çŸ¥è¯†

### ğŸ“– å®šä¹‰

**å›¾**ï¼ˆGraphï¼‰æ˜¯ç”±é¡¶ç‚¹ï¼ˆvertexï¼‰å’Œè¾¹ï¼ˆedgeï¼‰ç»„æˆçš„é›†åˆã€‚å›¾è®ºæ˜¯ç ”ç©¶å›¾çš„æ€§è´¨å’Œåº”ç”¨çš„æ•°å­¦åˆ†æ”¯ã€‚åœ¨ç®—æ³•ä¸­ï¼Œå›¾å¸¸ç”¨äºè¡¨ç¤ºå®ä½“ä¹‹é—´çš„å…³ç³»å’Œè¿æ¥ã€‚

### âš¡ æ ¸å¿ƒæ¦‚å¿µ

1. **é¡¶ç‚¹ï¼ˆVertex/Nodeï¼‰**ï¼šå›¾çš„åŸºæœ¬å…ƒç´ 
2. **è¾¹ï¼ˆEdgeï¼‰**ï¼šè¿æ¥ä¸¤ä¸ªé¡¶ç‚¹çš„çº¿æ®µ
3. **æœ‰å‘å›¾/æ— å‘å›¾**ï¼šè¾¹æ˜¯å¦æœ‰æ–¹å‘
4. **æƒé‡å›¾**ï¼šè¾¹æ˜¯å¦æœ‰æƒé‡
5. **è¿é€šå›¾**ï¼šä»»æ„ä¸¤ç‚¹éƒ½è¿é€š

### ğŸ¯ å›¾çš„è¡¨ç¤ºæ–¹æ³•

#### 1. é‚»æ¥çŸ©é˜µ
```python
# äºŒç»´æ•°ç»„è¡¨ç¤ºè¾¹ï¼Œé€‚åˆç¨ å¯†å›¾
graph = [
    [0, 1, 1],  # èŠ‚ç‚¹0è¿æ¥åˆ°1å’Œ2
    [1, 0, 0],  # èŠ‚ç‚¹1è¿æ¥åˆ°0
    [1, 0, 0]   # èŠ‚ç‚¹2è¿æ¥åˆ°0
]
```

#### 2. é‚»æ¥è¡¨
```python
# æ•°ç»„+é“¾è¡¨ï¼Œé€‚åˆç¨€ç–å›¾
graph = [
    [1, 2],      # èŠ‚ç‚¹0çš„é‚»å±…ï¼š1, 2
    [0],         # èŠ‚ç‚¹1çš„é‚»å±…ï¼š0
    [0]          # èŠ‚ç‚¹2çš„é‚»å±…ï¼š0
]
```

### ğŸ å›¾çš„éå†ç®—æ³•

#### 1. æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰
```python
def dfs(graph, node, visited):
    visited.add(node)
    print(node)  # è®¿é—®èŠ‚ç‚¹

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

#### 2. å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰
```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node)  # è®¿é—®èŠ‚ç‚¹

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### ğŸ“ å›¾è®ºåº”ç”¨åœºæ™¯

- **è¿é€šæ€§é—®é¢˜**ï¼šå²›å±¿æ•°é‡ã€æœ‹å‹åœˆ
- **æœ€çŸ­è·¯å¾„**ï¼šè¿·å®«ã€å¯¼èˆª
- **æ‹“æ‰‘æ’åº**ï¼šè¯¾ç¨‹å®‰æ’ã€ä¾èµ–å…³ç³»
- **æœ€å°ç”Ÿæˆæ ‘**ï¼šç½‘ç»œè®¾è®¡
- **å­—ç¬¦ä¸²å¤„ç†**ï¼šTrieæ ‘ã€å‰ç¼€åŒ¹é…

---

## ğŸ“‹ é¢˜ç›®ç›®å½•

| é¢˜å· | é¢˜ç›®åç§° | éš¾åº¦ | æ ¸å¿ƒæŠ€å·§ |
|------|----------|------|----------|
| 200 | å²›å±¿æ•°é‡ | ä¸­ç­‰ | DFS/BFSéå† |
| 994 | è…çƒ‚çš„æ©˜å­ | ä¸­ç­‰ | å¤šæºBFS |
| 207 | è¯¾ç¨‹è¡¨ | ä¸­ç­‰ | æ‹“æ‰‘æ’åº |
| 208 | å®ç° Trie | ä¸­ç­‰ | Trieæ ‘ |

---

## 200. å²›å±¿æ•°é‡

**é¢˜ç›®æè¿°ï¼š**

ç»™ä½ ä¸€ä¸ªç”± '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚

å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘å’Œ/æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚

**æµ‹è¯•ç”¨ä¾‹ï¼š**

```
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šgrid = [
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]
è¾“å‡ºï¼š1

ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šgrid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]
è¾“å‡ºï¼š3
```

**æœ€ç®€å•å®ç°ï¼š**

```python
def numIslands(grid):
    """
    å²›å±¿æ•°é‡ï¼šDFSéå†

    æ€è·¯ï¼š
    1. éå†ç½‘æ ¼ï¼Œé‡åˆ°'1'æ—¶å¼€å§‹DFS/BFS
    2. å°†ç›¸è¿çš„æ‰€æœ‰'1'æ ‡è®°ä¸ºå·²è®¿é—®ï¼ˆæ”¹ä¸º'0'ï¼‰
    3. æ¯æ¬¡DFS/BFSç®—ä½œä¸€ä¸ªå²›å±¿
    4. ç»Ÿè®¡å²›å±¿æ•°é‡

    æ—¶é—´å¤æ‚åº¦ï¼šO(m*n)
    ç©ºé—´å¤æ‚åº¦ï¼šO(m*n)ï¼Œæœ€åæƒ…å†µé€’å½’æ ˆæ·±åº¦
    """
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    count = 0

    def dfs(i, j):
        # è¾¹ç•Œæ£€æŸ¥å’Œæ°´åŸŸæ£€æŸ¥
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0':
            return

        # æ ‡è®°ä¸ºå·²è®¿é—®
        grid[i][j] = '0'

        # è®¿é—®å››ä¸ªæ–¹å‘
        dfs(i-1, j)  # ä¸Š
        dfs(i+1, j)  # ä¸‹
        dfs(i, j-1)  # å·¦
        dfs(i, j+1)  # å³

    # éå†ç½‘æ ¼
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)  # æ·¹æ²¡æ•´ä¸ªå²›å±¿

    return count

# BFSç‰ˆæœ¬
def numIslandsBFS(grid):
    """
    BFSç‰ˆæœ¬ï¼šä½¿ç”¨é˜Ÿåˆ—éå†

    æ—¶é—´å¤æ‚åº¦ï¼šO(m*n)
    ç©ºé—´å¤æ‚åº¦ï¼šO(min(m,n))
    """
    from collections import deque

    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    count = 0

    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                queue = deque([(i, j)])
                grid[i][j] = '0'  # æ ‡è®°å·²è®¿é—®

                while queue:
                    x, y = queue.popleft()

                    # æ£€æŸ¥å››ä¸ªæ–¹å‘
                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '1':
                            grid[nx][ny] = '0'
                            queue.append((nx, ny))

    return count

# æµ‹è¯•ç”¨ä¾‹
grid1 = [
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]
print(numIslands(grid1))  # è¾“å‡º: 1

grid2 = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]
print(numIslands(grid2))  # è¾“å‡º: 3
```

**è§£é¢˜æ€è·¯è¯¦è§£ï¼š**

è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯**å›¾çš„éå†**é—®é¢˜ï¼š

**æ ¸å¿ƒåŸç†ï¼š**
- å°†ç½‘æ ¼çœ‹ä½œæ— å‘å›¾ï¼Œæ¯ä¸ª'1'æ˜¯èŠ‚ç‚¹ï¼Œç›¸é‚»çš„'1'æœ‰è¾¹
- æ¯æ¬¡DFS/BFSéå†ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå°±æ˜¯ä¸€ä¸ªå²›å±¿
- ç»Ÿè®¡è¿é€šåˆ†é‡çš„æ•°é‡

**DFSæ–¹æ³•æµç¨‹ï¼š**
1. éå†ç½‘æ ¼ï¼Œé‡åˆ°'1'æ—¶å¼€å§‹DFS
2. DFSå°†æ‰€æœ‰ç›¸è¿çš„'1'æ ‡è®°ä¸º'0'
3. æ¯æ¬¡DFSç®—ä½œä¸€ä¸ªå²›å±¿
4. è¿”å›å²›å±¿æ•°é‡

**BFSæ–¹æ³•æµç¨‹ï¼š**
1. ä½¿ç”¨é˜Ÿåˆ—è¿›è¡Œå±‚æ¬¡éå†
2. å°†èµ·å§‹'1'å…¥é˜Ÿå¹¶æ ‡è®°
3. æ‰©å±•åˆ°æ‰€æœ‰ç›¸é‚»çš„'1'
4. æ¯æ¬¡BFSç®—ä½œä¸€ä¸ªå²›å±¿

**ä¸ºä»€ä¹ˆæœ‰æ•ˆï¼Ÿ**
- DFSé€’å½’éå†æ‰€æœ‰ç›¸è¿çš„é™†åœ°
- æ¯æ¬¡éå†éƒ½ä¼š"æ·¹æ²¡"ä¸€ä¸ªå²›å±¿
- é¿å…é‡å¤è®¡æ•°

**ä¸¾ä¾‹è¯´æ˜ï¼š**
```
grid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]

ç¬¬ä¸€æ¬¡æ‰¾åˆ°(0,0)ï¼ŒDFSæ·¹æ²¡ï¼š
  ['0','0','0','0','0'],
  ['0','0','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']

ç¬¬äºŒæ¬¡æ‰¾åˆ°(2,2)ï¼ŒDFSæ·¹æ²¡ï¼š
  ['0','0','0','0','0'],
  ['0','0','0','0','0'],
  ['0','0','0','0','0'],
  ['0','0','0','1','1']

ç¬¬ä¸‰æ¬¡æ‰¾åˆ°(3,3)ï¼ŒDFSæ·¹æ²¡ï¼š
  ['0','0','0','0','0'],
  ['0','0','0','0','0'],
  ['0','0','0','0','0'],
  ['0','0','0','0','0']

æ€»å…±3ä¸ªå²›å±¿ âœ“
```

**æ—¶é—´å¤æ‚åº¦è¯æ˜ï¼š**
- æ¯ä¸ªæ ¼å­æœ€å¤šè®¿é—®ä¸€æ¬¡ï¼šO(m*n)
- DFS/BFSçš„å¼€é”€ï¼šO(m*n)
- æ€»å¤æ‚åº¦ï¼šO(m*n)

---

## 994. è…çƒ‚çš„æ©˜å­

**é¢˜ç›®æè¿°ï¼š**

åœ¨ç»™å®šçš„ m x n ç½‘æ ¼ grid ä¸­ï¼Œæ¯ä¸ªå•å…ƒæ ¼å¯ä»¥æœ‰ä»¥ä¸‹ä¸‰ä¸ªå€¼ä¹‹ä¸€ï¼š

- å€¼ 0 ä»£è¡¨ç©ºå•å…ƒæ ¼ï¼›
- å€¼ 1 ä»£è¡¨æ–°é²œæ©˜å­ï¼›
- å€¼ 2 ä»£è¡¨è…çƒ‚çš„æ©˜å­ã€‚

æ¯åˆ†é’Ÿï¼Œè…çƒ‚çš„æ©˜å­ **å‘¨å›´ 4 ä¸ªæ–¹å‘ä¸Šç›¸é‚»** çš„æ–°é²œæ©˜å­éƒ½ä¼šè…çƒ‚ã€‚

è¿”å› ç›´åˆ°å•å…ƒæ ¼ä¸­æ²¡æœ‰æ–°é²œæ©˜å­ä¸ºæ­¢æ‰€å¿…é¡»ç»è¿‡çš„æœ€å°åˆ†é’Ÿæ•°ã€‚å¦‚æœä¸å¯èƒ½ï¼Œè¿”å› -1ã€‚

![è…çƒ‚çš„æ©˜å­ç¤ºæ„å›¾](./imgs/994.png)

**æµ‹è¯•ç”¨ä¾‹ï¼š**

```
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šgrid = [[2,1,1],[1,1,0],[0,1,1]]
è¾“å‡ºï¼š4

ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šgrid = [[2,1,1],[0,1,1],[1,0,1]]
è¾“å‡ºï¼š-1

ç¤ºä¾‹ 3ï¼š
è¾“å…¥ï¼šgrid = [[0,2]]
è¾“å‡ºï¼š0
```

**æœ€ç®€å•å®ç°ï¼š**

```python
from collections import deque

def orangesRotting(grid):
    """
    è…çƒ‚çš„æ©˜å­ï¼šå¤šæºBFS

    æ€è·¯ï¼š
    1. å°†æ‰€æœ‰è…çƒ‚æ©˜å­å…¥é˜Ÿï¼Œä½œä¸ºå¤šæºBFSèµ·ç‚¹
    2. ç»Ÿè®¡æ–°é²œæ©˜å­çš„æ•°é‡
    3. BFSæ¯åˆ†é’Ÿè…çƒ‚ç›¸é‚»çš„æ–°é²œæ©˜å­
    4. å¦‚æœè¿˜æœ‰æ–°é²œæ©˜å­ï¼Œè¿”å›-1

    æ—¶é—´å¤æ‚åº¦ï¼šO(m*n)
    ç©ºé—´å¤æ‚åº¦ï¼šO(m*n)
    """
    if not grid or not grid[0]:
        return 0

    m, n = len(grid), len(grid[0])
    queue = deque()
    fresh_count = 0

    # åˆå§‹åŒ–é˜Ÿåˆ—å’Œæ–°é²œæ©˜å­è®¡æ•°
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 2:
                queue.append((i, j))  # è…çƒ‚æ©˜å­å…¥é˜Ÿ
            elif grid[i][j] == 1:
                fresh_count += 1  # æ–°é²œæ©˜å­è®¡æ•°

    if fresh_count == 0:
        return 0  # æ²¡æœ‰æ–°é²œæ©˜å­

    minutes = 0
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # å››ä¸ªæ–¹å‘

    while queue and fresh_count > 0:
        minutes += 1
        # è¿™ä¸€åˆ†é’Ÿå†…è…çƒ‚çš„æ©˜å­æ•°é‡
        size = len(queue)

        for _ in range(size):
            x, y = queue.popleft()

            # è…çƒ‚å››ä¸ªæ–¹å‘çš„æ–°é²œæ©˜å­
            for dx, dy in directions:
                nx, ny = x + dx, y + dy

                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:
                    grid[nx][ny] = 2  # è…çƒ‚
                    fresh_count -= 1
                    queue.append((nx, ny))

    return minutes if fresh_count == 0 else -1

# æµ‹è¯•ç”¨ä¾‹
print(orangesRotting([[2,1,1],[1,1,0],[0,1,1]]))  # è¾“å‡º: 4
print(orangesRotting([[2,1,1],[0,1,1],[1,0,1]]))  # è¾“å‡º: -1
print(orangesRotting([[0,2]]))                     # è¾“å‡º: 0
```

**è§£é¢˜æ€è·¯è¯¦è§£ï¼š**

è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯**å¤šæºå¹¿åº¦ä¼˜å…ˆæœç´¢**ï¼š

**æ ¸å¿ƒåŸç†ï¼š**
- è…çƒ‚æ©˜å­åƒä¼ æŸ“ç—…ä¸€æ ·ä¼ æ’­
- æ¯æ¬¡BFSä¸€å±‚ï¼Œä»£è¡¨ä¸€åˆ†é’Ÿçš„ä¼ æ’­
- å¤šæºBFSï¼šæ‰€æœ‰è…çƒ‚æ©˜å­åŒæ—¶å¼€å§‹ä¼ æ’­

**ç®—æ³•æµç¨‹ï¼š**
1. åˆå§‹åŒ–é˜Ÿåˆ—ï¼šæ‰€æœ‰è…çƒ‚æ©˜å­å…¥é˜Ÿ
2. ç»Ÿè®¡æ–°é²œæ©˜å­æ•°é‡
3. BFSæ¯å±‚ä»£è¡¨ä¸€åˆ†é’Ÿï¼š
   - å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰è…çƒ‚æ©˜å­
   - è…çƒ‚ç›¸é‚»çš„æ–°é²œæ©˜å­
   - å…¥é˜Ÿæ–°è…çƒ‚çš„æ©˜å­
4. å¦‚æœè¿˜æœ‰æ–°é²œæ©˜å­ï¼Œè¿”å›-1

**ä¸ºä»€ä¹ˆä½¿ç”¨å¤šæºBFSï¼Ÿ**
- æ‰€æœ‰è…çƒ‚æ©˜å­åŒæ—¶å¼€å§‹ä¼ æ’­
- å¤©ç„¶çš„å±‚çº§ç»“æ„ï¼Œæ¯å±‚æ˜¯ä¸€åˆ†é’Ÿ
- èƒ½ç²¾ç¡®è®¡ç®—ä¼ æ’­æ—¶é—´

**ä¸¾ä¾‹è¯´æ˜ï¼š**
```
grid = [[2,1,1],[1,1,0],[0,1,1]]

åˆå§‹çŠ¶æ€ï¼š
2 1 1
1 1 0
0 1 1

ç¬¬0åˆ†é’Ÿï¼šè…çƒ‚æ©˜å­ä½ç½®(0,0)
æ–°é²œæ©˜å­ï¼š7ä¸ª

ç¬¬1åˆ†é’Ÿï¼šè…çƒ‚ç›¸é‚»çš„ï¼š(0,1),(1,0)
æ–°é²œæ©˜å­ï¼š5ä¸ª

ç¬¬2åˆ†é’Ÿï¼šç»§ç»­è…çƒ‚ï¼š(0,2),(1,1),(2,1)
æ–°é²œæ©˜å­ï¼š2ä¸ª

ç¬¬3åˆ†é’Ÿï¼šç»§ç»­è…çƒ‚ï¼š(1,2),(2,2)
æ–°é²œæ©˜å­ï¼š0ä¸ª

æ€»å…±4åˆ†é’Ÿ âœ“
```

**æ—¶é—´å¤æ‚åº¦è¯æ˜ï¼š**
- æ¯ä¸ªæ ¼å­æœ€å¤šè®¿é—®ä¸€æ¬¡ï¼šO(m*n)
- é˜Ÿåˆ—æ“ä½œï¼šO(m*n)
- æ€»å¤æ‚åº¦ï¼šO(m*n)

---

## 207. è¯¾ç¨‹è¡¨

**é¢˜ç›®æè¿°ï¼š**

ä½ è¿™ä¸ªå­¦æœŸå¿…é¡»é€‰ä¿® numCourses é—¨è¯¾ç¨‹ï¼Œè®°ä¸º 0 åˆ° numCourses - 1ã€‚

åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ å…ˆä¿®è¯¾ç¨‹æŒ‰æ•°ç»„ prerequisites ç»™å‡ºï¼Œå…¶ä¸­ prerequisites[i] = [ai, bi] ï¼Œè¡¨ç¤ºå¦‚æœè¦å­¦ä¹ è¯¾ç¨‹ ai åˆ™ **å¿…é¡» å…ˆå­¦ä¹ è¯¾ç¨‹ bi**ã€‚

ä¾‹å¦‚ï¼Œå…ˆä¿®è¯¾ç¨‹å¯¹ [0, 1] è¡¨ç¤ºï¼šæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1ã€‚

è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿå¦‚æœå¯ä»¥ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› falseã€‚

**æµ‹è¯•ç”¨ä¾‹ï¼š**

```
ç¤ºä¾‹ 1ï¼š
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0ã€‚è¿™æ˜¯å¯èƒ½çš„ã€‚

ç¤ºä¾‹ 2ï¼š
è¾“å…¥ï¼šnumCourses = 2, prerequisites = [[1,0],[0,1]]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 0ï¼›å¹¶ä¸”å­¦ä¹ è¯¾ç¨‹ 0 ä¹‹å‰ï¼Œä½ è¿˜åº”å…ˆå®Œæˆè¯¾ç¨‹ 1ã€‚è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚
```

**æœ€ç®€å•å®ç°ï¼š**

```python
from collections import deque

def canFinish(numCourses, prerequisites):
    """
    è¯¾ç¨‹è¡¨ï¼šæ‹“æ‰‘æ’åºï¼ˆBFSï¼‰

    æ€è·¯ï¼š
    1. æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    2. å°†å…¥åº¦ä¸º0çš„è¯¾ç¨‹å…¥é˜Ÿ
    3. BFSéå†ï¼Œé€æ¸å‡å°‘å…¶ä»–è¯¾ç¨‹çš„å…¥åº¦
    4. å¦‚æœæ‰€æœ‰è¯¾ç¨‹éƒ½èƒ½å®Œæˆï¼Œè¿”å›true

    æ—¶é—´å¤æ‚åº¦ï¼šO(V + E)
    ç©ºé—´å¤æ‚åº¦ï¼šO(V + E)
    """
    # æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
    graph = [[] for _ in range(numCourses)]  # graph[i]è¡¨ç¤ºè¯¾ç¨‹içš„åç»­è¯¾ç¨‹
    indegree = [0] * numCourses  # å…¥åº¦æ•°ç»„

    for course, prereq in prerequisites:
        graph[prereq].append(course)  # prereq -> course
        indegree[course] += 1

    # å°†å…¥åº¦ä¸º0çš„è¯¾ç¨‹å…¥é˜Ÿ
    queue = deque([i for i in range(numCourses) if indegree[i] == 0])
    completed = 0  # å·²å®Œæˆçš„è¯¾ç¨‹æ•°

    while queue:
        course = queue.popleft()
        completed += 1

        # å‡å°‘åç»­è¯¾ç¨‹çš„å…¥åº¦
        for next_course in graph[course]:
            indegree[next_course] -= 1
            if indegree[next_course] == 0:
                queue.append(next_course)

    return completed == numCourses

# DFSç‰ˆæœ¬
def canFinishDFS(numCourses, prerequisites):
    """
    DFSç‰ˆæœ¬ï¼šæ£€æµ‹æœ‰å‘å›¾æ˜¯å¦æœ‰ç¯

    æ—¶é—´å¤æ‚åº¦ï¼šO(V + E)
    ç©ºé—´å¤æ‚åº¦ï¼šO(V + E)
    """
    # æ„å»ºé‚»æ¥è¡¨
    graph = [[] for _ in range(numCourses)]
    for course, prereq in prerequisites:
        graph[prereq].append(course)

    # è®¿é—®çŠ¶æ€ï¼š0-æœªè®¿é—®ï¼Œ1-æ­£åœ¨è®¿é—®ï¼Œ2-å·²è®¿é—®
    visited = [0] * numCourses

    def dfs(course):
        if visited[course] == 1:  # æ­£åœ¨è®¿é—®ï¼Œè¯´æ˜æœ‰ç¯
            return False
        if visited[course] == 2:  # å·²è®¿é—®è¿‡
            return True

        visited[course] = 1  # æ ‡è®°æ­£åœ¨è®¿é—®

        for next_course in graph[course]:
            if not dfs(next_course):
                return False

        visited[course] = 2  # æ ‡è®°å·²è®¿é—®
        return True

    # æ£€æŸ¥æ‰€æœ‰è¯¾ç¨‹
    for i in range(numCourses):
        if visited[i] == 0 and not dfs(i):
            return False

    return True

# æµ‹è¯•ç”¨ä¾‹
print(canFinish(2, [[1,0]]))        # è¾“å‡º: True
print(canFinish(2, [[1,0],[0,1]]))  # è¾“å‡º: False
```

**è§£é¢˜æ€è·¯è¯¦è§£ï¼š**

è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯**æ‹“æ‰‘æ’åº**ï¼ˆæ£€æµ‹æœ‰å‘å›¾æ˜¯å¦æœ‰ç¯ï¼‰ï¼š

**æ ¸å¿ƒåŸç†ï¼š**
- è¯¾ç¨‹å®‰æ’æ˜¯ä¸€ä¸ªæœ‰å‘å›¾
- è¾¹è¡¨ç¤ºä¾èµ–å…³ç³»ï¼ˆprereq â†’ courseï¼‰
- æ‹“æ‰‘æ’åºå¯ä»¥æ£€æµ‹æ˜¯å¦èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹
- å¦‚æœæœ‰ç¯ï¼Œè¯´æ˜å­˜åœ¨å¾ªç¯ä¾èµ–ï¼Œæ— æ³•å®Œæˆ

**BFSæ–¹æ³•ï¼ˆKahnç®—æ³•ï¼‰ï¼š**
1. æ„å»ºé‚»æ¥è¡¨å’Œå…¥åº¦æ•°ç»„
2. å°†å…¥åº¦ä¸º0çš„è¯¾ç¨‹å…¥é˜Ÿ
3. BFSéå†ï¼Œå‡å°‘åç»­è¯¾ç¨‹å…¥åº¦
4. ç»Ÿè®¡å®Œæˆçš„è¯¾ç¨‹æ•°

**DFSæ–¹æ³•ï¼š**
1. æ„å»ºé‚»æ¥è¡¨
2. DFSéå†ï¼Œæ£€æµ‹æ˜¯å¦æœ‰ç¯
3. ä¸‰ç§çŠ¶æ€ï¼šæœªè®¿é—®ã€æ­£åœ¨è®¿é—®ã€å·²è®¿é—®

**ä¸ºä»€ä¹ˆæœ‰æ•ˆï¼Ÿ**
- å…¥åº¦ä¸º0çš„è¯¾ç¨‹å¯ä»¥ç›´æ¥å­¦ä¹ 
- å­¦ä¹ å®Œä¸€é—¨è¯¾ç¨‹åï¼Œå…¶åç»­è¯¾ç¨‹å…¥åº¦å‡1
- å¦‚æœæ‰€æœ‰è¯¾ç¨‹éƒ½èƒ½å®Œæˆï¼Œè¯´æ˜æ— ç¯

**ä¸¾ä¾‹è¯´æ˜ï¼š**
```
numCourses = 2, prerequisites = [[1,0]]

é‚»æ¥è¡¨ï¼šgraph[0] = [1], graph[1] = []
å…¥åº¦ï¼š[0, 1]

å…¥åº¦ä¸º0çš„è¯¾ç¨‹ï¼š[0]
å­¦ä¹ 0åï¼Œ1çš„å…¥åº¦å˜ä¸º0
å†å­¦ä¹ 1

å®Œæˆæ‰€æœ‰è¯¾ç¨‹ âœ“

prerequisites = [[1,0],[0,1]]

é‚»æ¥è¡¨ï¼šgraph[0] = [1], graph[1] = [0]
å…¥åº¦ï¼š[1, 1]

æ²¡æœ‰å…¥åº¦ä¸º0çš„è¯¾ç¨‹ï¼Œæ— æ³•å¼€å§‹å­¦ä¹  âœ—
```

**æ—¶é—´å¤æ‚åº¦è¯æ˜ï¼š**
- æ„å»ºå›¾ï¼šO(E)
- BFS/DFSéå†ï¼šO(V + E)
- æ€»å¤æ‚åº¦ï¼šO(V + E)

---

## 208. å®ç° Trie

**é¢˜ç›®æè¿°ï¼š**

Trieï¼ˆå‘éŸ³ç±»ä¼¼ "try"ï¼‰æˆ–è€…è¯´ **å‰ç¼€æ ‘** æ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æ„ï¼Œç”¨äºé«˜æ•ˆåœ°å­˜å‚¨å’Œæ£€ç´¢å­—ç¬¦ä¸²æ•°æ®é›†ä¸­çš„é”®ã€‚è¿™ä¸€æ•°æ®ç»“æ„æœ‰ç›¸å½“å¤šçš„åº”ç”¨æƒ…æ™¯ï¼Œä¾‹å¦‚è‡ªåŠ¨è¡¥å…¨å’Œæ‹¼å†™æ£€æŸ¥ã€‚

è¯·ä½ å®ç° Trie ç±»ï¼š

- Trie() åˆå§‹åŒ–å‰ç¼€æ ‘å¯¹è±¡ã€‚
- void insert(String word) å‘å‰ç¼€æ ‘ä¸­æ’å…¥å­—ç¬¦ä¸² wordã€‚
- boolean search(String word) å¦‚æœå­—ç¬¦ä¸² word åœ¨å‰ç¼€æ ‘ä¸­ï¼Œè¿”å› trueï¼ˆå³ï¼Œåœ¨æ£€ç´¢ä¹‹å‰å·²ç»æ’å…¥ï¼‰ï¼›å¦åˆ™ï¼Œè¿”å› falseã€‚
- boolean startsWith(String prefix) å¦‚æœä¹‹å‰å·²ç»æ’å…¥çš„å­—ç¬¦ä¸² word çš„å‰ç¼€ä¹‹ä¸€ä¸º prefix ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› falseã€‚

**æµ‹è¯•ç”¨ä¾‹ï¼š**

```
ç¤ºä¾‹ï¼š
è¾“å…¥
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]

è¾“å‡º
[null, null, true, false, true, null, true]

è§£é‡Š
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // è¿”å› True
trie.search("app");     // è¿”å› False
trie.startsWith("app"); // è¿”å› True
trie.insert("app");
trie.search("app");     // è¿”å› True
```

**æœ€ç®€å•å®ç°ï¼š**

```python
class TrieNode:
    """TrieèŠ‚ç‚¹"""
    def __init__(self):
        self.children = {}  # å­èŠ‚ç‚¹å­—å…¸
        self.is_end = False  # æ˜¯å¦æ˜¯å•è¯ç»“å°¾

class Trie:
    """
    Trieï¼ˆå‰ç¼€æ ‘ï¼‰å®ç°

    æ€è·¯ï¼š
    1. æ¯ä¸ªèŠ‚ç‚¹åŒ…å«å­èŠ‚ç‚¹å­—å…¸å’Œç»“æŸæ ‡å¿—
    2. æ’å…¥ï¼šé€å­—ç¬¦åˆ›å»ºèŠ‚ç‚¹ï¼Œæœ€åæ ‡è®°ç»“æŸ
    3. æŸ¥æ‰¾ï¼šé€å­—ç¬¦æŸ¥æ‰¾ï¼Œæ£€æŸ¥æ˜¯å¦å®Œæ•´å•è¯
    4. å‰ç¼€æŸ¥æ‰¾ï¼šé€å­—ç¬¦æŸ¥æ‰¾ï¼Œä¸éœ€è¦æ£€æŸ¥ç»“æŸæ ‡å¿—

    æ—¶é—´å¤æ‚åº¦ï¼šæ’å…¥å’ŒæŸ¥æ‰¾éƒ½æ˜¯O(m)ï¼Œmæ˜¯å­—ç¬¦ä¸²é•¿åº¦
    ç©ºé—´å¤æ‚åº¦ï¼šO(æ€»å­—ç¬¦æ•°)
    """

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

# æµ‹è¯•ç”¨ä¾‹
trie = Trie()
trie.insert("apple")
print(trie.search("apple"))   # è¾“å‡º: True
print(trie.search("app"))     # è¾“å‡º: False
print(trie.startsWith("app")) # è¾“å‡º: True
trie.insert("app")
print(trie.search("app"))     # è¾“å‡º: True
```

**è§£é¢˜æ€è·¯è¯¦è§£ï¼š**

è¿™é“é¢˜çš„æ ¸å¿ƒæ˜¯å®ç°**Trieæ ‘æ•°æ®ç»“æ„**ï¼š

**æ ¸å¿ƒåŸç†ï¼š**
- Trieæ ‘æ˜¯ä¸€ç§å‰ç¼€æ ‘
- æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ä¸€ä¸ªå­—ç¬¦
- è·¯å¾„ä»£è¡¨ä¸€ä¸ªå­—ç¬¦ä¸²
- èŠ‚ç‚¹å¯ä»¥æ ‡è®°å•è¯ç»“æŸ

**æ•°æ®ç»“æ„è®¾è®¡ï¼š**
- TrieNodeï¼šåŒ…å«childrenå­—å…¸å’Œis_endæ ‡å¿—
- rootï¼šæ ¹èŠ‚ç‚¹ï¼Œä¸å­˜å‚¨å­—ç¬¦

**insertæ–¹æ³•ï¼š**
1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€å­—ç¬¦åˆ›å»ºèŠ‚ç‚¹
2. é‡åˆ°æ–°å­—ç¬¦åˆ›å»ºæ–°èŠ‚ç‚¹
3. æœ€åè®¾ç½®is_end = True

**searchæ–¹æ³•ï¼š**
1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€å­—ç¬¦æŸ¥æ‰¾
2. æ‰¾ä¸åˆ°å­—ç¬¦è¿”å›False
3. æ‰¾åˆ°æ‰€æœ‰å­—ç¬¦åï¼Œæ£€æŸ¥is_end

**startsWithæ–¹æ³•ï¼š**
1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€å­—ç¬¦æŸ¥æ‰¾
2. åªè¦èƒ½æ‰¾åˆ°æ‰€æœ‰å­—ç¬¦å°±è¿”å›True
3. ä¸éœ€è¦æ£€æŸ¥is_end

**ä¸¾ä¾‹è¯´æ˜ï¼š**
```
æ’å…¥"apple"ï¼š

root
â”œâ”€â”€ 'a'
    â”œâ”€â”€ 'p'
        â”œâ”€â”€ 'p'
            â”œâ”€â”€ 'l'
                â””â”€â”€ 'e' (is_end=True)

æŸ¥æ‰¾"app"ï¼š
ä»root -> 'a' -> 'p' -> 'p'ï¼Œä½†is_end=Falseï¼Œè¿”å›False

æŸ¥æ‰¾å‰ç¼€"app"ï¼š
ä»root -> 'a' -> 'p' -> 'p'ï¼Œèƒ½æ‰¾åˆ°ï¼Œè¿”å›True
```

**æ—¶é—´å¤æ‚åº¦è¯æ˜ï¼š**
- æ’å…¥ï¼šO(m)ï¼Œmæ˜¯å­—ç¬¦ä¸²é•¿åº¦
- æŸ¥æ‰¾ï¼šO(m)
- ç©ºé—´ï¼šO(æ€»å­—ç¬¦æ•°)ï¼Œå…±äº«å‰ç¼€èŠ‚çœç©ºé—´

---

## ğŸ¯ å›¾è®ºè§£é¢˜æŠ€å·§æ€»ç»“

### 1. å›¾çš„éå†æ¨¡æ¿

#### DFSé€’å½’æ¨¡æ¿
```python
def dfs(graph, node, visited):
    visited.add(node)
    # å¤„ç†å½“å‰èŠ‚ç‚¹

    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

#### DFSæ ˆæ¨¡æ¿
```python
def dfs_stack(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            # å¤„ç†èŠ‚ç‚¹
            for neighbor in graph[node]:
                if neighbor not in visited:
                    stack.append(neighbor)
```

#### BFSæ¨¡æ¿
```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        # å¤„ç†èŠ‚ç‚¹

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 2. æ‹“æ‰‘æ’åºæ¨¡æ¿

#### BFSç‰ˆæœ¬ï¼ˆKahnç®—æ³•ï¼‰
```python
def topological_sort(graph, indegree):
    from collections import deque

    queue = deque([node for node in graph if indegree[node] == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)

    return result if len(result) == len(graph) else []  # æœ‰ç¯è¿”å›ç©º
```

#### DFSç‰ˆæœ¬
```python
def topological_sort_dfs(graph):
    visited = [0] * len(graph)  # 0:æœªè®¿é—®, 1:æ­£åœ¨è®¿é—®, 2:å·²è®¿é—®
    result = []

    def dfs(node):
        if visited[node] == 1:  # æœ‰ç¯
            return False
        if visited[node] == 2:  # å·²è®¿é—®
            return True

        visited[node] = 1
        for neighbor in graph[node]:
            if not dfs(neighbor):
                return False

        visited[node] = 2
        result.append(node)
        return True

    for node in range(len(graph)):
        if visited[node] == 0 and not dfs(node):
            return []

    result.reverse()  # DFSç»“æœéœ€è¦åè½¬
    return result
```

### 3. Trieæ ‘æ¨¡æ¿
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def startsWith(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

### ğŸ’¡ è§£é¢˜æŠ€å·§

1. **å›¾çš„å»ºæ¨¡**ï¼š
   - æ˜ç¡®èŠ‚ç‚¹å’Œè¾¹çš„å«ä¹‰
   - é€‰æ‹©åˆé€‚çš„è¡¨ç¤ºæ–¹æ³•ï¼ˆé‚»æ¥è¡¨/çŸ©é˜µï¼‰
   - è€ƒè™‘æœ‰å‘å›¾è¿˜æ˜¯æ— å‘å›¾

2. **éå†é€‰æ‹©**ï¼š
   - DFSï¼šé€‚åˆæ¢ç´¢æ‰€æœ‰å¯èƒ½æ€§ã€å¯»æ‰¾è·¯å¾„
   - BFSï¼šé€‚åˆå¯»æ‰¾æœ€çŸ­è·¯å¾„ã€å±‚çº§éå†
   - é€’å½’DFSï¼šä»£ç ç®€æ´ï¼Œä½†å¯èƒ½æ ˆæº¢å‡º
   - æ ˆDFSï¼šé¿å…é€’å½’æ·±åº¦é™åˆ¶

3. **å¸¸è§é—®é¢˜ç±»å‹**ï¼š
   - **è¿é€šæ€§**ï¼šDFS/BFSéå†ï¼Œè®¡æ•°è¿é€šåˆ†é‡
   - **æœ€çŸ­è·¯å¾„**ï¼šBFSï¼ˆæ— æƒå›¾ï¼‰ã€Dijkstraï¼ˆæœ‰æƒå›¾ï¼‰
   - **æ‹“æ‰‘æ’åº**ï¼šæ£€æµ‹ä¾èµ–å…³ç³»ã€ä»»åŠ¡è°ƒåº¦
   - **å­—ç¬¦ä¸²å¤„ç†**ï¼šTrieæ ‘ã€å‰ç¼€åŒ¹é…

4. **ä¼˜åŒ–æŠ€å·§**ï¼š
   - **å‰ªæ**ï¼šæå‰ç»ˆæ­¢æ— æ•ˆæœç´¢
   - **è®°å¿†åŒ–**ï¼šé¿å…é‡å¤è®¡ç®—
   - **åŒå‘BFS**ï¼šåŒæ—¶ä»èµ·ç‚¹å’Œç»ˆç‚¹æœç´¢
   - **A*ç®—æ³•**ï¼šå¯å‘å¼æœç´¢

å›¾è®ºæ˜¯ç®—æ³•ä¸­éå¸¸é‡è¦çš„ä¸€éƒ¨åˆ†ï¼ŒæŒæ¡åŸºæœ¬çš„å›¾éå†ç®—æ³•å’Œåº”ç”¨åœºæ™¯ï¼Œèƒ½è§£å†³å¾ˆå¤šå®é™…é—®é¢˜ï¼