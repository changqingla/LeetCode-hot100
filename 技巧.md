# 技巧专题

## 🔍 技巧类问题基础知识

### 📖 定义

**技巧类问题**主要考察算法思维和编程技巧，往往需要巧妙的思路来解决看似复杂的问题。这些问题通常有特定的解题套路，如位运算、投票算法、双指针等。

### ⚡ 核心特征

1. **思维转换**：将复杂问题转化为简单问题
2. **空间优化**：常要求O(1)空间复杂度
3. **时间优化**：追求最优时间复杂度
4. **原地操作**：不允许使用额外空间

### 🎯 常见解题技巧

1. **位运算**：利用二进制位的特性解决计数、查找等问题
2. **投票算法**：用于寻找多数元素
3. **快慢指针**：解决链表环、数组重复等问题
4. **原地哈希**：利用数组本身作为哈希表
5. **数学公式**：利用数学规律直接计算

### 🐍 位运算基础

```python
# 基本位运算
a & b   # 按位与
a | b   # 按位或
a ^ b   # 按位异或
~a      # 按位取反
a << n  # 左移n位
a >> n  # 右移n位

# 常用技巧
# 1. 判断奇偶：x & 1
# 2. 消除最低位1：x & (x - 1)
# 3. 获取最低位1：x & -x
# 4. 交换两个数：a ^= b; b ^= a; a ^= b
```

### 📏 投票算法

```python
# Boyer-Moore投票算法：寻找多数元素
def majority_vote(nums):
    candidate = None
    count = 0

    for num in nums:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1

    return candidate
```

### 📏 快慢指针

```python
# 寻找数组重复数（Floyd判圈算法）
def find_duplicate(nums):
    slow = fast = nums[0]

    # 第一阶段：找到相遇点
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    # 第二阶段：找到环入口
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow
```

---

## 📋 题目目录

| 题号 | 题目名称 | 难度 | 核心技巧 |
|------|----------|------|----------|
| 136 | 只出现一次的数字 | 简单 | 位运算 |
| 169 | 多数元素 | 简单 | 投票算法 |
| 75 | 颜色分类 | 中等 | 三指针 |
| 31 | 下一个排列 | 中等 | 排列算法 |
| 287 | 寻找重复数 | 中等 | 快慢指针 |

---

## 136. 只出现一次的数字

**题目描述：**

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**测试用例：**

```
示例 1：
输入：nums = [2,2,1]
输出：1

示例 2：
输入：nums = [4,1,2,1,2]
输出：4

示例 3：
输入：nums = [1]
输出：1
```

**最简单实现：**

```python
def singleNumber(nums):
    """
    只出现一次的数字：使用异或运算

    思路：
    1. 异或运算满足交换律和结合律：a ^ b ^ a = b
    2. 任何数和自己异或结果为0：a ^ a = 0
    3. 任何数和0异或结果为自己：a ^ 0 = a
    4. 因此，将所有数字异或，最终只剩下出现一次的数字

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    result = 0
    for num in nums:
        result ^= num
    return result

# 更直观的实现
def singleNumberClear(nums):
    """
    更清晰的实现
    """
    xor_result = nums[0]
    for i in range(1, len(nums)):
        xor_result ^= nums[i]
    return xor_result

# 测试用例
print(singleNumber([2,2,1]))      # 输出: 1
print(singleNumber([4,1,2,1,2]))  # 输出: 4
print(singleNumber([1]))          # 输出: 1
```

**解题思路详解：**

这道题的核心是利用**异或运算的性质**：

**异或运算的性质：**
- 交换律：a ^ b = b ^ a
- 结合律：(a ^ b) ^ c = a ^ (b ^ c)
- 自反性：a ^ a = 0
- 恒等性：a ^ 0 = a

**算法原理：**
- 每个出现两次的数字都会和自己异或得到0
- 只出现一次的数字和0异或得到自己
- 最终结果就是只出现一次的数字

**举例说明：**
```
nums = [2,2,1]

初始：result = 0

第一步：result = 0 ^ 2 = 2
第二步：result = 2 ^ 2 = 0
第三步：result = 0 ^ 1 = 1

最终结果：1 ✓
```

**为什么不使用哈希表？**
- 哈希表需要O(n)空间，不满足常量空间要求
- 异或运算只需要O(1)空间

**时间复杂度证明：**
- 单次遍历数组：O(n)
- 每个元素只进行一次异或操作：O(1)
- 总复杂度：O(n)

---

## 169. 多数元素

**题目描述：**

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**测试用例：**

```
示例 1：
输入：nums = [3,2,3]
输出：3

示例 2：
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

**最简单实现：**

```python
def majorityElement(nums):
    """
    多数元素：使用投票算法

    思路：
    1. 维护一个候选者和计数器
    2. 遍历数组：
       - 如果计数器为0，选择当前元素为候选者
       - 如果当前元素等于候选者，计数器+1
       - 否则计数器-1
    3. 最终候选者就是多数元素

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    candidate = None
    count = 0

    for num in nums:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1

    return candidate

# 验证版本（确保确实是多数元素）
def majorityElementWithVerification(nums):
    """
    包含验证步骤的版本
    """
    candidate = majorityElement(nums)

    # 验证候选者是否确实是多数元素
    count = sum(1 for num in nums if num == candidate)
    if count > len(nums) // 2:
        return candidate
    else:
        return None  # 理论上不会发生

# 测试用例
print(majorityElement([3,2,3]))          # 输出: 3
print(majorityElement([2,2,1,1,1,2,2]))  # 输出: 2
```

**解题思路详解：**

这道题的核心是**Boyer-Moore投票算法**：

**核心原理：**
- 多数元素出现的次数超过n/2
- 其他元素两两抵消，最后剩下的就是多数元素

**算法流程：**
1. 初始化candidate=None, count=0
2. 遍历数组：
   - 如果count==0，选择当前元素为candidate，count=1
   - 如果当前元素==candidate，count++
   - 否则count--
3. 最终candidate就是多数元素

**为什么这样有效？**
- 多数元素和其他元素两两抵消后，仍有剩余
- 非多数元素无法在最后胜出

**举例说明：**
```
nums = [2,2,1,1,1,2,2]

初始：candidate=None, count=0

i=0: count=0，candidate=2, count=1
i=1: 2==2，count=2
i=2: 1!=2，count=1
i=3: 1!=2，count=0
i=4: count=0，candidate=1, count=1
i=5: 2!=1，count=0
i=6: count=0，candidate=2, count=1

最终candidate=2 ✓
```

**时间复杂度证明：**
- 单次遍历数组：O(n)
- 每个元素只进行常数操作：O(1)
- 总复杂度：O(n)

---

## 75. 颜色分类

**题目描述：**

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**测试用例：**

```
示例 1：
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

示例 2：
输入：nums = [2,0,1]
输出：[0,1,2]
```

**最简单实现：**

```python
def sortColors(nums):
    """
    颜色分类：使用三指针（荷兰国旗问题）

    思路：
    1. 使用三个指针：left, right, current
    2. left指向0的右边界，right指向2的左边界
    3. current遍历数组：
       - 遇到0：与left交换，left++, current++
       - 遇到1：current++
       - 遇到2：与right交换，right--

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    if not nums:
        return

    left = 0  # 指向0的右边界
    right = len(nums) - 1  # 指向2的左边界
    current = 0  # 当前遍历位置

    while current <= right:
        if nums[current] == 0:
            # 遇到0，与left位置交换
            nums[current], nums[left] = nums[left], nums[current]
            left += 1
            current += 1
        elif nums[current] == 1:
            # 遇到1，继续前进
            current += 1
        else:  # nums[current] == 2
            # 遇到2，与right位置交换
            nums[current], nums[right] = nums[right], nums[current]
            right -= 1
            # 注意：current不前进，因为换过来的元素需要重新判断

# 测试用例
nums1 = [2,0,2,1,1,0]
sortColors(nums1)
print(nums1)  # 输出: [0,0,1,1,2,2]

nums2 = [2,0,1]
sortColors(nums2)
print(nums2)  # 输出: [0,1,2]
```

**计数排序版本：**

```python
def sortColorsCounting(nums):
    """
    计数排序版本：统计三种颜色的数量

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    count = [0] * 3  # count[0], count[1], count[2]

    # 统计每种颜色的数量
    for num in nums:
        count[num] += 1

    # 重写数组
    index = 0
    for color in range(3):
        for _ in range(count[color]):
            nums[index] = color
            index += 1

# 测试用例
nums = [2,0,2,1,1,0]
sortColorsCounting(nums)
print(nums)  # 输出: [0,0,1,1,2,2]
```

**解题思路详解：**

这道题的核心是**荷兰国旗问题**的三指针解法：

**核心原理：**
- 将数组分成三个区域：0的区域、1的区域、2的区域
- 使用三个指针维护这三个区域的边界

**指针含义：**
- left：0的右边界（[0, left)都是0）
- current：当前遍历位置
- right：2的左边界（(right, n-1]都是2）

**算法流程：**
1. 初始化left=0, current=0, right=n-1
2. 当current <= right时：
   - nums[current] == 0：与left交换，left++, current++
   - nums[current] == 1：current++
   - nums[current] == 2：与right交换，right--

**为什么遇到2时current不前进？**
- 从right换过来的元素可能是0、1、2中的任意一个
- 需要重新判断这个元素

**举例说明：**
```
nums = [2,0,2,1,1,0], left=0, current=0, right=5

current=0: nums[0]=2，与right=5交换 → [0,0,2,1,1,2], right=4
current=0: nums[0]=0，与left=0交换 → [0,0,2,1,1,2], left=1, current=1

current=1: nums[1]=0，与left=1交换 → [0,0,2,1,1,2], left=2, current=2

current=2: nums[2]=2，与right=4交换 → [0,0,1,1,1,2], right=3
current=2: nums[2]=1，current=3

current=3: nums[3]=1，current=4

current=4: nums[4]=1，current=5

current=5 > right=3，结束

最终结果：[0,0,1,1,1,2] ✓
```

**时间复杂度证明：**
- 单次遍历数组：O(n)
- 每个元素最多被交换两次：O(1)
- 总复杂度：O(n)

---

## 31. 下一个排列

**题目描述：**

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

**测试用例：**

```
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]

示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]

示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
```

**最简单实现：**

```python
def nextPermutation(nums):
    """
    下一个排列：字典序算法

    思路：
    1. 从右向左找到第一个降序的位置i（nums[i] < nums[i+1]）
    2. 从右向左找到第一个大于nums[i]的元素j
    3. 交换nums[i]和nums[j]
    4. 反转i+1到末尾的子数组

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    n = len(nums)

    # 第一步：从右向左找到第一个降序的位置
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1

    if i >= 0:
        # 第二步：从右向左找到第一个大于nums[i]的元素
        j = n - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1

        # 第三步：交换nums[i]和nums[j]
        nums[i], nums[j] = nums[j], nums[i]

    # 第四步：反转i+1到末尾的子数组
    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1

# 测试用例
nums1 = [1,2,3]
nextPermutation(nums1)
print(nums1)  # 输出: [1,3,2]

nums2 = [3,2,1]
nextPermutation(nums2)
print(nums2)  # 输出: [1,2,3]

nums3 = [1,1,5]
nextPermutation(nums3)
print(nums3)  # 输出: [1,5,1]
```

**解题思路详解：**

这道题的核心是**字典序排列算法**：

**核心原理：**
- 在所有排列中找到下一个更大的排列
- 如果不存在，则返回最小的排列（升序）

**算法流程：**
1. **找到降序位置**：从右向左找到第一个nums[i] < nums[i+1]的位置
2. **找到交换元素**：从右向左找到第一个大于nums[i]的元素nums[j]
3. **交换元素**：交换nums[i]和nums[j]
4. **反转后缀**：反转i+1到末尾的子数组，使其变为升序

**为什么这样有效？**
- 步骤1找到需要改变的位置
- 步骤2找到最小的更大元素进行交换
- 步骤3-4保证新的排列是下一个更大的排列

**举例说明：**
```
nums = [1,2,3]

步骤1：从右向左找降序位置
i=1: nums[1]=2 < nums[2]=3，找到i=1

步骤2：从右向左找第一个大于nums[1]=2的元素
j=2: nums[2]=3 > 2，找到j=2

步骤3：交换nums[1]和nums[2] → [1,3,2]

步骤4：反转2到末尾 → [1,3,2]（只有一个元素，无需反转）

最终结果：[1,3,2] ✓
```

**另一个例子：**
```
nums = [3,2,1]

步骤1：从右向左找降序位置
i=2: nums[2]=1没有右边元素
i=1: nums[1]=2 >= nums[2]=1
i=0: nums[0]=3 >= nums[1]=2
没有找到降序位置i=-1

步骤4：反转整个数组 → [1,2,3]

最终结果：[1,2,3] ✓
```

**时间复杂度证明：**
- 找到降序位置：O(n)
- 找到交换元素：O(n)
- 反转后缀：O(n)
- 总复杂度：O(n)

---

## 287. 寻找重复数

**题目描述：**

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。

你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

**测试用例：**

```
示例 1：
输入：nums = [1,3,4,2,2]
输出：2

示例 2：
输入：nums = [3,1,3,4,2]
输出：3

示例 3：
输入：nums = [3,3,3,3,3]
输出：3
```

**最简单实现：**

```python
def findDuplicate(nums):
    """
    寻找重复数：使用快慢指针（Floyd判圈算法）

    思路：
    1. 将数组看作链表，nums[i]指向索引i
    2. 由于有重复数，会形成环
    3. 使用快慢指针找到环的入口（重复数）

    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    # 快慢指针第一阶段：找到相遇点
    slow = nums[0]
    fast = nums[0]

    while True:
        slow = nums[slow]  # 慢指针走一步
        fast = nums[nums[fast]]  # 快指针走两步
        if slow == fast:
            break

    # 快慢指针第二阶段：找到环入口
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow

# 二分查找版本
def findDuplicateBinary(nums):
    """
    二分查找版本：统计小于等于mid的元素个数

    时间复杂度：O(n log n)
    空间复杂度：O(1)
    """
    left, right = 1, len(nums) - 1

    while left < right:
        mid = (left + right) // 2
        count = sum(1 for num in nums if num <= mid)

        if count > mid:
            # 重复数在[left, mid]
            right = mid
        else:
            # 重复数在[mid+1, right]
            left = mid + 1

    return left

# 测试用例
print(findDuplicate([1,3,4,2,2]))  # 输出: 2
print(findDuplicate([3,1,3,4,2]))  # 输出: 3
print(findDuplicate([3,3,3,3,3]))  # 输出: 3
```

**解题思路详解：**

这道题的核心是使用**Floyd判圈算法**（快慢指针）：

**核心原理：**
- 数组元素在[1,n]范围内，共有n+1个元素
- 将数组看作链表：索引i指向nums[i]
- 重复元素会导致环的形成
- 环的入口就是重复的元素

**算法流程：**
1. **第一阶段**：快慢指针找到相遇点
   - slow = nums[slow]
   - fast = nums[nums[fast]]
2. **第二阶段**：找到环入口
   - slow回到起点
   - slow和fast同时前进，每次一步
   - 相遇点就是环入口（重复数）

**为什么这样有效？**
- 重复数作为环入口，所有指向它的元素都会进入这个环
- Floyd算法可以找到链表环的入口

**举例说明：**
```
nums = [1,3,4,2,2]
索引:  0,1,2,3,4
值:   [1,3,4,2,2]

链表结构：
0 → 1 → 3 → 2 → 4 → 2 → 4 → ...
             ↑     ↓
             └─────┘

环入口是2（重复数）
```

**时间复杂度证明：**
- 第一阶段：O(n)
- 第二阶段：O(n)
- 总复杂度：O(n)

---

## 🎯 技巧类问题解题总结

### 1. 位运算技巧
```python
# 异或消除重复元素
def xor_trick(nums):
    result = 0
    for num in nums:
        result ^= num
    return result

# 统计二进制中1的个数
def count_bits(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

# 消除最低位1
def clear_lowest_bit(n):
    return n & (n - 1)
```

### 2. 投票算法模板
```python
def majority_vote(nums):
    candidate = None
    count = 0

    for num in nums:
        if count == 0:
            candidate = num
        count += 1 if num == candidate else -1

    return candidate
```

### 3. 快慢指针模板
```python
# 寻找环入口
def find_cycle_start(nums):
    slow = fast = nums[0]

    # 第一阶段：找到相遇点
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break

    # 第二阶段：找到环入口
    slow = nums[0]
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

    return slow
```

### 4. 原地哈希技巧
```python
# 使用数组本身作为哈希表
def in_place_hash(nums):
    for i in range(len(nums)):
        while nums[i] != i + 1 and nums[i] != nums[nums[i] - 1]:
            # 交换到正确位置
            temp = nums[i]
            nums[i], nums[temp - 1] = nums[temp - 1], nums[i]
```

### 💡 解题技巧

1. **思维转换**：将问题转化为已知的数据结构问题
2. **数学规律**：利用数学性质简化问题
3. **边界处理**：注意特殊情况和边界条件
4. **空间优化**：追求O(1)空间复杂度
5. **时间优化**：利用算法的特性降低时间复杂度

技巧类问题往往需要跳出常规思维，寻找问题的本质规律！
